import {Change, ChangeType} from "../change/change";
import {Subject} from "rxjs";

/**
 * Stores and constantly updates the json (as an instance of the DontCodeSchema) as it is being edited / modified through Change events
 * It does not store the entity values but the description of entities, screens... as defined in the Editor
 */
export class DontCodeModelManager {
  protected content: any;

  /**
   * Returns the complete json stored
   */
  getContent (): any {
    return this.content;
  }

  /**
   * Resets the current json content to the one given in parameter
   * @param newContent
   */
  resetContent (newContent: any) {
    this.content = newContent;
  }

  /**
   * Subscribes to the Subject in parameter to receive model updates through changes.
   * Changes are generated by the Editor as the user modifies the application.
   * It then modifies it's internal json to be up to date.
   * @param receivedCommands
   */
  receiveUpdatesFrom(receivedCommands: Subject<Change>) {
    receivedCommands.subscribe (change => {
        const parentPos = change.position.substring (0, change.position.lastIndexOf ('/'));
        const prop = change.position.substring (change.position.lastIndexOf ('/')+1);
        const parent = this.findAtPosition (parentPos, true);
        switch (change.type) {
          case ChangeType.ADD:
          case ChangeType.UPDATE:
          case ChangeType.RESET:
            if( prop==="") {
                // We have to update (or reset) the existing parent itself, not a subproperty represented by prop
              if( change.type===ChangeType.RESET) {
                for (let subProp in parent) {
                  delete parent[subProp];
                }
              }
              for (let subProp in change.value) {
                parent[subProp]=change.value[subProp];
              }
            } else {
              parent[prop]=change.value;
            }
            break;
          case ChangeType.DELETE:
            delete parent[prop];
            break;
          case ChangeType.MOVE: {
            const oldParentPos = change.oldPosition.substring(0, change.oldPosition.lastIndexOf('/'));
            const oldProp = change.oldPosition.substring(change.oldPosition.lastIndexOf('/') + 1);
            const oldParent = this.findAtPosition(oldParentPos, false);

            // If needed, ensure the order of property is correct in target
            const val = oldParent[oldProp];
            delete oldParent[oldProp];
            if (change.beforeKey) {
              const keys = Object.keys(parent);
              for (const key of keys) {
                const copy = parent[key];
                delete parent[key];
                if (key === change.beforeKey) {
                  parent[prop] = val;
                }
                parent[key] = copy;
              }
            } else {
              parent[prop] = val;
            }
            break;
          }
        }
      }

    )
  }

  /**
   * Provides the json extract at the given position.
   * For example, findAtPosition ('creation/entities/a') will returns the description (fields...) of the first entity created with the editor
   * @param position
   * @param create
   */
  findAtPosition (position:string, create?:boolean): any {
    const path=position.split ('/');
    if (this.content == null) {
      if( create) {
        this.content = {
          creation: {
            type:'application',
            name:'unknown'
          }
        }
      } else {
        return null;
      }
    }

    let current = this.content;

    path.forEach(element => {
      if( element==="")
        return current;
      if (! current[element]) {
        if (create) {
          current[element]={};
        } else
        {
          return null;
        }
      }

      current = current[element];
    });
    return current;
  }

}
