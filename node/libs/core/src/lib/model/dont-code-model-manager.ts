import {Change, ChangeType} from "../change/change";
import {Subject} from "rxjs";
import {DontCodeSchemaItem} from "./dont-code-schema-item";
import {dtcde} from "../globals";
import {DontCodeSchemaManager} from "./dont-code-schema-manager";
import {JSONPath} from 'jsonpath-plus';
/**
 * Stores and constantly updates the json (as an instance of the DontCodeSchema) as it is being edited / modified through Change events
 * It does not store the entity values but the description of entities, screens... as defined in the Editor
 */
export class DontCodeModelManager {
  protected content: any;

  constructor(protected schemaMgr: DontCodeSchemaManager) {
  }

  /**
   * Returns the complete json stored
   */
  getContent (): any {
    return this.content;
  }

  /**
   * Resets the current json content to the one given in parameter
   * @param newContent
   */
  resetContent (newContent: any) {
    this.content = newContent;
  }

  /**
   * Subscribes to the Subject in parameter to receive model updates through changes.
   * Changes are generated by the Editor as the user modifies the application.
   * It then modifies it's internal json to be up to date.
   * @param receivedCommands
   */
  receiveUpdatesFrom(receivedCommands: Subject<Change>) {
    receivedCommands.subscribe (change => {
        const parentPos = change.position.substring (0, change.position.lastIndexOf ('/'));
        const prop = change.position.substring (change.position.lastIndexOf ('/')+1);
        const parent = this.findAtPosition (parentPos, true);
        switch (change.type) {
          case ChangeType.ADD:
          case ChangeType.UPDATE:
          case ChangeType.RESET:
            if( prop==="") {
                // We have to update (or reset) the existing parent itself, not a subproperty represented by prop
              if( change.type===ChangeType.RESET) {
                for (const subProp in parent) {
                  delete parent[subProp];
                }
              }
              for (const subProp in change.value) {
                parent[subProp]=change.value[subProp];
              }
            } else {
              parent[prop]=change.value;
            }
            break;
          case ChangeType.DELETE:
            delete parent[prop];
            break;
          case ChangeType.MOVE: {
            if (change.oldPosition) {
              const oldParentPos = change.oldPosition.substring(0, change.oldPosition.lastIndexOf('/'));
              const oldProp = change.oldPosition.substring(change.oldPosition.lastIndexOf('/') + 1);
              const oldParent = this.findAtPosition(oldParentPos, false);

              // If needed, ensure the order of property is correct in target
              const val = oldParent[oldProp];
              delete oldParent[oldProp];
              if (change.beforeKey) {
                const keys = Object.keys(parent);
                for (const key of keys) {
                  const copy = parent[key];
                  delete parent[key];
                  if (key === change.beforeKey) {
                    parent[prop] = val;
                  }
                  parent[key] = copy;
                }
              } else {
                parent[prop] = val;
              }
            } else {
              throw Error ('We need oldPosition to process MOVE change '+change.position);
            }
            break;
          }
        }
      }

    )
  }

  /**
   * Provides the json extract at the given position.
   * For example, findAtPosition ('creation/entities/a') will returns the description (fields...) of the first entity created with the editor
   * @param position
   * @param create
   */
  findAtPosition (position:string, create?:boolean): any {
    const path=position.split ('/');
    if (this.content == null) {
      if( create) {
        this.content = {
          creation: {
            type:'application',
            name:'unknown'
          }
        }
      } else {
        return null;
      }
    }

    let current = this.content;

    path.forEach(element => {
      if( (element==="") || (current===null))
        return current;
      if (! current[element]) {
        if (create) {
          current[element]={};
        } else
        {
          current=null;
          return null;
        }
      }

      current = current[element];
    });
    return current;
  }

  /**
   * Enable querying the model for any value, following jsonPath model
   * To use when potentially you expect multiple values
   * @param query: the query as a jsonPath
   * @param if the jsonPath contains a placeholder, it's value is given here
   * @param position: in case the jsonPath is relative
   */
  queryModelToArray (query: string, position?: string): Array<any> {
    let root = this.content;
    if (position) {
      root = this.findAtPosition(position, false);
    }
    const result = JSONPath({path:query, json:root, resultType: "value", wrap:false, flatten:true});
    return result;
  }

  /**
   * Enable querying the model for any value, following jsonPath model
   * To use when potentially you expect a single value.
   * @param query: the query as a  jsonPath
   * @param position: in case the jsonPath is relative
   */
  queryModelToSingle (query: string, position?:string): any {
    let root = this.content;
    if (position) {
      root = this.findAtPosition(position, false);
    }
    const result = JSONPath({path:query, json:root, resultType: "value", wrap:false});
    if (Array.isArray(result)) {
      if( result.length<=1)
        return result[0];
      else throw new Error ("Mulitple results returned by queryModelToSingle with path "+query);
    }
    return result;
  }

  findAllPossibleTargetsOfProperty(property: string, position: string, schemaItem?:DontCodeSchemaItem): Array<any> {
    if( !schemaItem) {
      const ptr = this.schemaMgr.generateSchemaPointer(position);
      schemaItem = this.schemaMgr.locateItem(ptr.subPropertyPointer(property).schemaPosition, true);
    }
    const targetPath = schemaItem?.getTargetPath();
    if ((schemaItem) && (targetPath)) {
      const lastDotPos = targetPath.lastIndexOf('.');
      return this.queryModelToArray(targetPath.substring(0, lastDotPos)+'.*');
    }
    else {
      throw new Error("No Schema or no format definition for "+position+'/'+property);
    }
  }

  findTargetOfProperty(property: string, position: string, schemaItem?:DontCodeSchemaItem): any {
    const src = this.findAtPosition(position, false);
    if ((src) && (src[property])) {
      if( !schemaItem) {
        const ptr = this.schemaMgr.generateSchemaPointer(position);
        schemaItem = this.schemaMgr.locateItem(ptr.subPropertyPointer(property).schemaPosition, true);
      }
      const targetPath = schemaItem?.getTargetPath();
      if ((schemaItem)&&(targetPath)) {
        const lastDotPos = targetPath.lastIndexOf('.');
//        const filteredQuery = targetPath.substring(0, lastDotPos)+'[?(@.'+targetPath.substring(lastDotPos+1)+'==="'+src[property]+'")]';
        const filteredQuery = targetPath.substring(0, lastDotPos)+'[?(@[\''+targetPath.substring(lastDotPos+1)+'\']==="'+src[property]+'")]';
        return this.queryModelToSingle(filteredQuery);
      } else {
        throw new Error("No Schema or no format definition for "+position+'/'+property);
      }
    }
    return undefined;
  }
}
